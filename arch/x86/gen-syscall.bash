#!/bin/bash

# This script generates the classic BPF program to intercept system calls
# in x86 userspace.

# From asm/unistd_64.h
declare -A x86_64_syscalls=(
	["mknod"]="133"
	["mknodat"]="259"
)

# From asm/unistd_32.h
declare -A i386_syscalls=(
	["mknod"]="14"
	["mknodat"]="297"

	["stat64"]="195"
	["lstat64"]="196"
	["fstat64"]="197"
	["fstatat64"]="300"
	["statx"]="383"
)

prelude=(
	# Check that we're running on x86_64 or i386
	'BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, arch)))'
	'BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_I386, $(($i386_offset-2)), 0)'
	'BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0)'
	'BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS)'

	# The x32 ABI (not to be confused with the i386 ABI!) uses the
	# same system call numbers as x86_64, but set bit 30. Clear it so we share
	# the same table.
	'BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, nr)))'
	'BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, X32_SYSCALL_BIT, 0, 1)'
	'BPF_STMT(BPF_ALU | BPF_SUB | BPF_K, X32_SYSCALL_BIT)'
)

syscall_jump=(
	'BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, $nr, 0, 1)'
	'BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_USER_NOTIF)'
)

i386_offset=$((${#prelude[@]} + ${#syscall_jump[@]}*${#x86_64_syscalls[@]} + 1))

# NOTE: indentation is done with tabs. Do not use spaces, do not remove tabs,
# lest you break all HEREDOCs.

gen_source() {
	cat <<-EOF
	/* THIS FILE WAS GENERATED BY arch/x86/gen-syscall.bash -- DO NOT EDIT */
	
	#include <stddef.h>
	#include <linux/audit.h>
	#include <linux/bpf_common.h>
	#include <linux/filter.h>
	#include <linux/seccomp.h>
	
	/* For the x32 ABI, all system call numbers have bit 30 set */
	#define X32_SYSCALL_BIT 0x40000000
	
	const struct sock_filter syscall_filter[] = {
	EOF

	for stmt in "${prelude[@]}"; do
		eval "echo $'\t'\"$stmt\","
	done

	for syscall in "${!x86_64_syscalls[@]}"; do
		nr=${x86_64_syscalls[$syscall]}
		for stmt in "${syscall_jump[@]}"; do
			eval "echo $'\t'\"$stmt\","
		done
	done

	echo $'\t''BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),'
	echo $'\t''BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, nr))),'

	for syscall in "${!i386_syscalls[@]}"; do
		nr=${i386_syscalls[$syscall]}
		for stmt in "${syscall_jump[@]}"; do
			eval "echo $'\t'\"$stmt\","
		done
	done

	echo $'\t''BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),'

	cat <<-EOF
	};
	
	const size_t syscall_filter_length = sizeof (syscall_filter) / sizeof (struct sock_filter);

	/* THIS FILE WAS GENERATED BY arch/x86/gen-syscall.bash -- DO NOT EDIT */
	EOF
}

gen_header() {
	cat <<-EOF
	/* THIS FILE WAS GENERATED BY arch/x86/gen-syscall.bash -- DO NOT EDIT */

	extern const struct sock_filter syscall_filter[];
	extern const size_t syscall_filter_length;

	EOF

	for syscall in "${!x86_64_syscalls[@]}"; do
		echo "#define BST_NR_${syscall} ${x86_64_syscalls[$syscall]}"
	done

	for syscall in "${!i386_syscalls[@]}"; do
		echo "#define BST_NR_${syscall}_32 ${i386_syscalls[$syscall]}"
	done

	max=0
	for syscall in "${!x86_64_syscalls[@]}"; do
		(( ${x86_64_syscalls[$syscall]} > max )) && max=${x86_64_syscalls[$syscall]}
	done

	max32=0
	for syscall in "${!i386_syscalls[@]}"; do
		(( ${i386_syscalls[$syscall]} > max32 )) && max32=${i386_syscalls[$syscall]}
	done

	cat <<-EOF

	#define BST_SECCOMP_32 1

	#define BST_NR_MAX $max
	#define BST_NR_MAX32 $max32

	/* THIS FILE WAS GENERATED BY arch/x86/gen-syscall.bash -- DO NOT EDIT */
	EOF
}

gen_source > arch/x86/syscall.c
gen_header > arch/x86/syscall.h
